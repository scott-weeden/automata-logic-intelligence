# Additional cells for 02_cfg_pda.ipynb

additional_cells = '''
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Palindromes with Center Marker\\n",
    "\\n",
    "PDA for palindromes of the form wcw^R where w ∈ {a,b}*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# PDA for palindromes wcw^R\\n",
    "palindrome_pda = PDA(\\n",
    "    states={'q0', 'q1', 'q2'},\\n",
    "    alphabet={'a', 'b', 'c'},\\n",
    "    stack_alphabet={'Z', 'A', 'B'},\\n",
    "    transitions={\\n",
    "        # Push phase: read w and push onto stack\\n",
    "        ('q0', 'a', 'Z'): {('q0', 'AZ')},\\n",
    "        ('q0', 'a', 'A'): {('q0', 'AA')},\\n",
    "        ('q0', 'a', 'B'): {('q0', 'AB')},\\n",
    "        ('q0', 'b', 'Z'): {('q0', 'BZ')},\\n",
    "        ('q0', 'b', 'A'): {('q0', 'BA')},\\n",
    "        ('q0', 'b', 'B'): {('q0', 'BB')},\\n",
    "        \\n",
    "        # Center marker: transition to pop phase\\n",
    "        ('q0', 'c', 'Z'): {('q1', 'Z')},\\n",
    "        ('q0', 'c', 'A'): {('q1', 'A')},\\n",
    "        ('q0', 'c', 'B'): {('q1', 'B')},\\n",
    "        \\n",
    "        # Pop phase: match w^R\\n",
    "        ('q1', 'a', 'A'): {('q1', '')},\\n",
    "        ('q1', 'b', 'B'): {('q1', '')},\\n",
    "        ('q1', '', 'Z'): {('q2', 'Z')}\\n",
    "    },\\n",
    "    start_state='q0',\\n",
    "    accept_states={'q2'}\\n",
    ")\\n",
    "\\n",
    "# Test palindromes\\n",
    "test_cases = [\\n",
    "    ('c', True),\\n",
    "    ('aca', True),\\n",
    "    ('bcb', True),\\n",
    "    ('abcba', True),\\n",
    "    ('aabcbaa', True),\\n",
    "    ('abacaba', False),  # No center marker\\n",
    "    ('abc', False),\\n",
    "    ('abcab', False)\\n",
    "]\\n",
    "\\n",
    "print('Testing PDA for palindromes wcw^R:')\\n",
    "for string, expected in test_cases:\\n",
    "    result = palindrome_pda.accepts(string)\\n",
    "    status = '✓' if result == expected else '✗'\\n",
    "    print(f\"'{string}': {'ACCEPT' if result else 'REJECT'} {status}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 4. Context-Free Grammar Concepts\\n",
    "\\n",
    "Understanding the relationship between CFGs and PDAs."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simulate CFG derivation for balanced parentheses\\n",
    "# Grammar: S -> ε | (S) | SS\\n",
    "\\n",
    "def generate_balanced_parens(n):\\n",
    "    \"\"\"Generate all balanced parentheses strings of length 2n\"\"\"\\n",
    "    if n == 0:\\n",
    "        return ['']\\n",
    "    \\n",
    "    result = []\\n",
    "    for i in range(n):\\n",
    "        # S -> (S1)S2 where |S1| = 2i, |S2| = 2(n-1-i)\\n",
    "        left_strings = generate_balanced_parens(i)\\n",
    "        right_strings = generate_balanced_parens(n-1-i)\\n",
    "        \\n",
    "        for left in left_strings:\\n",
    "            for right in right_strings:\\n",
    "                result.append('(' + left + ')' + right)\\n",
    "    \\n",
    "    return result\\n",
    "\\n",
    "# Generate and test small examples\\n",
    "print('CFG Generation of Balanced Parentheses:')\\n",
    "for n in range(4):\\n",
    "    strings = generate_balanced_parens(n)\\n",
    "    print(f'n={n} (length {2*n}): {strings}')\\n",
    "    \\n",
    "    # Verify with PDA\\n",
    "    for s in strings:\\n",
    "        if not balanced_parens.accepts(s):\\n",
    "            print(f'ERROR: PDA rejected {s}')\\n",
    "            \\n",
    "print('\\nAll generated strings accepted by PDA ✓')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 5. Non-Deterministic PDA Behavior\\n",
    "\\n",
    "Exploring the power of non-determinism in pushdown automata."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Non-deterministic PDA: accepts ww^R or palindromes without center marker\\n",
    "palindrome_no_center = PDA(\\n",
    "    states={'q0', 'q1', 'q2'},\\n",
    "    alphabet={'a', 'b'},\\n",
    "    stack_alphabet={'Z', 'A', 'B'},\\n",
    "    transitions={\\n",
    "        # Push phase\\n",
    "        ('q0', 'a', 'Z'): {('q0', 'AZ')},\\n",
    "        ('q0', 'a', 'A'): {('q0', 'AA')},\\n",
    "        ('q0', 'a', 'B'): {('q0', 'AB')},\\n",
    "        ('q0', 'b', 'Z'): {('q0', 'BZ')},\\n",
    "        ('q0', 'b', 'A'): {('q0', 'BA')},\\n",
    "        ('q0', 'b', 'B'): {('q0', 'BB')},\\n",
    "        \\n",
    "        # Non-deterministic choice: guess middle of palindrome\\n",
    "        ('q0', '', 'Z'): {('q1', 'Z')},    # Even length palindrome\\n",
    "        ('q0', '', 'A'): {('q1', 'A')},\\n",
    "        ('q0', '', 'B'): {('q1', 'B')},\\n",
    "        ('q0', 'a', 'A'): {('q1', '')},    # Odd length, center is 'a'\\n",
    "        ('q0', 'b', 'B'): {('q1', '')},    # Odd length, center is 'b'\\n",
    "        \\n",
    "        # Pop phase\\n",
    "        ('q1', 'a', 'A'): {('q1', '')},\\n",
    "        ('q1', 'b', 'B'): {('q1', '')},\\n",
    "        ('q1', '', 'Z'): {('q2', 'Z')}\\n",
    "    },\\n",
    "    start_state='q0',\\n",
    "    accept_states={'q2'}\\n",
    ")\\n",
    "\\n",
    "# Test palindromes without center marker\\n",
    "test_cases = [\\n",
    "    ('', True),\\n",
    "    ('a', True),\\n",
    "    ('b', True),\\n",
    "    ('aa', True),\\n",
    "    ('bb', True),\\n",
    "    ('aba', True),\\n",
    "    ('bab', True),\\n",
    "    ('abba', True),\\n",
    "    ('baab', True),\\n",
    "    ('ab', False),\\n",
    "    ('abc', False),\\n",
    "    ('abca', False)\\n",
    "]\\n",
    "\\n",
    "print('Testing Non-deterministic PDA for palindromes:')\\n",
    "for string, expected in test_cases:\\n",
    "    result = palindrome_no_center.accepts(string)\\n",
    "    status = '✓' if result == expected else '✗'\\n",
    "    print(f\"'{string}': {'ACCEPT' if result else 'REJECT'} {status}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. Context-Free Pumping Lemma\\n",
    "\\n",
    "The pumping lemma for context-free languages."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cf_pumping_demo(string, language_checker):\\n",
    "    \"\"\"\\n",
    "    Demonstrate context-free pumping lemma.\\n",
    "    For CF languages, strings can be divided into uvxyz where\\n",
    "    |vxy| <= p, |vy| > 0, and uv^i xy^i z is in the language for all i >= 0.\\n",
    "    \"\"\"\\n",
    "    n = len(string)\\n",
    "    if n < 5:  # Need reasonable length for pumping\\n",
    "        return f'String too short for meaningful pumping'\\n",
    "    \\n",
    "    # Try different divisions (simplified)\\n",
    "    for v_start in range(1, n-2):\\n",
    "        for v_end in range(v_start+1, min(v_start+3, n-1)):\\n",
    "            for y_start in range(v_end, n-1):\\n",
    "                for y_end in range(y_start+1, min(y_start+3, n)):\\n",
    "                    u = string[:v_start]\\n",
    "                    v = string[v_start:v_end]\\n",
    "                    x = string[v_end:y_start]\\n",
    "                    y = string[y_start:y_end]\\n",
    "                    z = string[y_end:]\\n",
    "                    \\n",
    "                    if len(v) == 0 and len(y) == 0:\\n",
    "                        continue\\n",
    "                    \\n",
    "                    # Test pumping\\n",
    "                    pumped = [\\n",
    "                        u + x + z,              # i=0\\n",
    "                        u + v + x + y + z,      # i=1 (original)\\n",
    "                        u + v*2 + x + y*2 + z   # i=2\\n",
    "                    ]\\n",
    "                    \\n",
    "                    results = [language_checker(s) for s in pumped]\\n",
    "                    \\n",
    "                    if all(results):\\n",
    "                        return f'Pumpable: u=\"{u}\", v=\"{v}\", x=\"{x}\", y=\"{y}\", z=\"{z}\"'\\n",
    "    \\n",
    "    return 'No valid pumping found'\\n",
    "\\n",
    "# Test CF pumping on our languages\\n",
    "print('Context-Free Pumping Lemma Demonstrations:')\\n",
    "\\n",
    "test_string = 'aaabbb'\\n",
    "result = cf_pumping_demo(test_string, a_n_b_n.accepts)\\n",
    "print(f'a^n b^n with \"{test_string}\": {result}')\\n",
    "\\n",
    "test_string = '(((())))'\\n",
    "result = cf_pumping_demo(test_string, balanced_parens.accepts)\\n",
    "print(f'Balanced parens with \"{test_string}\": {result}')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 7. Conclusion\\n",
    "\\n",
    "### Key Concepts Learned:\\n",
    "\\n",
    "1. **Pushdown Automata**: Stack-based computation for context-free languages\\n",
    "2. **Stack Operations**: Push, pop, and epsilon transitions\\n",
    "3. **Non-determinism**: Guessing and backtracking in PDAs\\n",
    "4. **Context-Free Languages**: Beyond regular language capabilities\\n",
    "5. **CFG Equivalence**: Grammars and PDAs recognize the same languages\\n",
    "6. **Pumping Lemma**: Tool for proving non-context-freeness\\n",
    "\\n",
    "### Applications:\\n",
    "- Programming language parsing\\n",
    "- Compiler design\\n",
    "- XML/HTML validation\\n",
    "- Mathematical expression evaluation\\n",
    "\\n",
    "### Next Steps:\\n",
    "- Explore Turing machines and undecidability\\n",
    "- Study context-sensitive languages\\n",
    "- Learn about parsing algorithms\\n",
    "- Investigate compiler construction techniques"
   ]
  }
'''

print("Additional cells content prepared for 02_cfg_pda.ipynb")
print("This content should be manually added to complete the notebook.")
